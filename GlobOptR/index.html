<!DOCTYPE doctype html>

<html lang="en">
<head><title>Testing optimisation algorithms: Part III - Global optimisation in R</title>
<meta charset="utf-8">

<meta content="" name="description"/>
<link href="../CLstyle.css" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
</link></link></meta></head>
<body><header><h1>Testing optimisation algorithms: Part III - Global optimisation in R</h1><time datetime="2011-09-18T21:12:00Z">21:12 Sunday 18th September 2011</time></header><article>In <a href="http://cnr.lwlss.net/CirclePackingObjective">part I</a> of this series of posts, I presented the maths behind posing <a href="http://en.wikipedia.org/wiki/Circle_packing">circle packing</a> as a high-dimensional, non-linear, constrained <a href="http://en.wikipedia.org/wiki/Mathematical_optimization">optimisation</a> problem.  I am using this problem as an example to try out various <a href="http://en.wikipedia.org/wiki/Mathematical_optimization">optimisation</a> algorithms.  In <a href="http://cnr.lwlss.net/CircleObjectivesR">part II</a> I demonstrated an implementation of this problem in <a href="http://www.r-project.org"></a>R, together with an <a href="http://www.r-project.org"></a>R function for visualising candidate solutions.
<br/>
<br/>In this post, I will describe some findings from attempts to optimise the circle packing objective function with <a href="http://www.r-project.org/">R</a>'s default, general-purpose optimisation package: <a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/optim.html">optim</a> and two other packages for performing global optimisation using <a href="http://en.wikipedia.org/wiki/Genetic_algorithm">genetic algorithms</a> with derivative-based intermediate searches.
<br/>
<br/>I have updated the code from the last post slightly (added two more small functions).  You can download the updated version here: <a href="http://lwlss.net/dwnlds/CirclePacking.R">CirclePacking.R</a>.  I've also written a second script demonstrating the use of the functions in <a href="http://lwlss.net/dwnlds/CirclePacking.R">CirclePacking.R</a> in combination with the 3 optimisation packages mentioned above: <a href="http://lwlss.net/dwnlds/TestingOptimisation.R">TestingOptimisation.R</a> (duplicated at the bottom of this post).  Running this code generates plots like the one below, visualising solutions, together with some statistics about running time distributions and packing density distributions for ensembles of solutions.
<br/>
<br/><a href="http://www.flickr.com/photos/conchur/6159948456/" title="L-BFGS-BN4_200 by Conor Lawless, on Flickr"><img alt="L-BFGS-BN4_200" height="500" src="http://farm7.static.flickr.com/6077/6159948456_dd85d3a2b0.jpg" width="498"/></a>
<br/>64 solutions for packing 200 circles into a square with the <a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/optim.html">optim</a> package.
<br/>
<br/>The <a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/optim.html">optim</a> package includes an implementation of the <a href="http://en.wikipedia.org/wiki/Limited-memory_BFGS">L-BFGS-B</a> algorithm, which is an efficient, derivative-based local optimiser allowing lower and upper bounds to be placed on parameters.
<br/>
<br/>The <a href="http://sekhon.berkeley.edu/rgenoud/">rgenoud</a> package uses <a href="http://en.wikipedia.org/wiki/Genetic_algorithm">genetic algorithms</a> and <a href="http://en.wikipedia.org/wiki/Derivative">derivatives</a> to solve global optimisation problems.  I used it successfully to fit a <a href="http://en.wikipedia.org/wiki/Mixture_density">mixture model</a> to pixel intensity <a href="http://en.wikipedia.org/wiki/Image_histogram">distributions</a> as part of the <a href="http://en.wikipedia.org/wiki/Segmentation_(image_processing)">segmentation</a> step in the <a href="http://en.wikipedia.org/wiki/Image_analysis">image analysis</a> tool: <a href="http://research.ncl.ac.uk/colonyzer/">Colonyzer</a>.  It also has some interesting functionality for distributing computing load across multiple CPUs, by using a <a href="http://cran.r-project.org/web/packages/snow/index.html">snow</a> cluster which I wanted to investigate.    
<br/>
<br/>The <a href="http://cran.r-project.org/web/packages/DEoptim/index.html">DEoptim</a> package also uses <a href="http://en.wikipedia.org/wiki/Genetic_algorithm">genetic algorithms</a> and <a href="http://en.wikipedia.org/wiki/Derivative">derivatives</a> to solve global optimisation problems.  I have previously found that this algorithm was faster than <a href="http://sekhon.berkeley.edu/rgenoud/">rgenoud</a> when automatically fitting a <a href="http://en.wikipedia.org/wiki/Logistic_function#In_ecology:_modeling_population_growth">logistic model</a> to yeast growth curves in <a href="http://qfa.r-forge.r-project.org/">Quantitative Fitness Analysis</a>. 
<br/>
<br/><h2>Results</h2>
<br/>
<br/>My findings are problem-specific, and depend on the number of circles allowed (which you can vary by modifying the code below) but so far, they are as follows:
<br/>
<br/>1) For all N I've tried (up to 200), the <a href="http://en.wikipedia.org/wiki/Limited-memory_BFGS">L-BFGS-B</a> algorithm was fastest.  It achieved the same packing densities, but in shorter times. 
<br/>
<br/>2) Using the <a href="http://sekhon.berkeley.edu/rgenoud/">rgenoud</a> cluster functionality did not speed up the genoud algorithm, or improve the packing densities of its solutions. 
<br/>
<br/>3) <a href="http://cran.r-project.org/web/packages/DEoptim/index.html">DEoptim</a> crashes with mysterious errors for N&gt;200 (more than 600 parameters) on a 64-bit machine with 12 Gb RAM.  However, this is probably many more parameters than are required for most practical purposes.
<br/>
<br/>4) <a href="http://sekhon.berkeley.edu/rgenoud/">rgenoud</a> was much faster than <a href="http://cran.r-project.org/web/packages/DEoptim/index.html">DEoptim</a> in this case (achieved the same or higher packing densities more quickly).
<br/>
<br/>It's difficult to draw solid conclusions from this analysis, as I now suspect that for the circle packing problem, there are many local minima with largely similar packing densities and so it may be difficult or impossible to distinguish between local optima and a global optimum (if it exists).  This would explain result 1) and possibly result 2).  Result 1) was particularly surprising since I expected this high-dimensional problem to be very vulnerable to getting stuck in local minima, and so I expected global optimisers to be more efficient.  As mentioned above, result 4) is reversed for at least one other optimisation problem.  
<br/>
<br/>I'm happy with the solutions (see image above), they have very pleasing organic patterns.
<br/>
<br/><!-- HTML generated using hilite.me --><div style="background: #f8f8f8; overflow:auto;width:auto;color:black;background:white;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">  1
<br/>  2
<br/>  3
<br/>  4
<br/>  5
<br/>  6
<br/>  7
<br/>  8
<br/>  9
<br/> 10
<br/> 11
<br/> 12
<br/> 13
<br/> 14
<br/> 15
<br/> 16
<br/> 17
<br/> 18
<br/> 19
<br/> 20
<br/> 21
<br/> 22
<br/> 23
<br/> 24
<br/> 25
<br/> 26
<br/> 27
<br/> 28
<br/> 29
<br/> 30
<br/> 31
<br/> 32
<br/> 33
<br/> 34
<br/> 35
<br/> 36
<br/> 37
<br/> 38
<br/> 39
<br/> 40
<br/> 41
<br/> 42
<br/> 43
<br/> 44
<br/> 45
<br/> 46
<br/> 47
<br/> 48
<br/> 49
<br/> 50
<br/> 51
<br/> 52
<br/> 53
<br/> 54
<br/> 55
<br/> 56
<br/> 57
<br/> 58
<br/> 59
<br/> 60
<br/> 61
<br/> 62
<br/> 63
<br/> 64
<br/> 65
<br/> 66
<br/> 67
<br/> 68
<br/> 69
<br/> 70
<br/> 71
<br/> 72
<br/> 73
<br/> 74
<br/> 75
<br/> 76
<br/> 77
<br/> 78
<br/> 79
<br/> 80
<br/> 81
<br/> 82
<br/> 83
<br/> 84
<br/> 85
<br/> 86
<br/> 87
<br/> 88
<br/> 89
<br/> 90
<br/> 91
<br/> 92
<br/> 93
<br/> 94
<br/> 95
<br/> 96
<br/> 97
<br/> 98
<br/> 99
<br/>100
<br/>101
<br/>102
<br/>103
<br/>104
<br/>105
<br/>106
<br/>107
<br/>108
<br/>109
<br/>110
<br/>111
<br/>112
<br/>113
<br/>114
<br/>115
<br/>116
<br/>117
<br/>118
<br/>119
<br/>120</pre></td><td><pre style="margin: 0; line-height: 125%">library(DEoptim)
<br/>library(rgenoud)
<br/>library(snow)
<br/>source(<span style="color: #BA2121">&quot;CirclePacking.R&quot;</span>)
<br/>
<br/><span style="color: #408080; font-style: italic"># Number of circles and dimensions of bounding rectangle </span>
<br/>N<span style="color: #666666">=100</span>; W<span style="color: #666666">=10</span>; H<span style="color: #666666">=10</span>
<br/>root<span style="color: #666666">=</span><span style="color: #BA2121">&quot;N64_100&quot;</span>
<br/>arrnum<span style="color: #666666">=64</span>
<br/>arrdim<span style="color: #666666">=</span>ceiling(sqrt(arrnum))
<br/>
<br/><span style="color: #408080; font-style: italic"># Create objective function</span>
<br/>obj<span style="color: #666666">=</span>createObj(N,W,H)
<br/>
<br/><span style="color: #408080; font-style: italic"># Lowest acceptable values for dimensions (x,y) is zero</span>
<br/><span style="color: #408080; font-style: italic"># Minimum radius (to prevent circles being optimised out of existance)</span>
<br/>low<span style="color: #666666">=</span>rep(c(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>,<span style="color: #666666">0.01*</span>min(W,H)),N)
<br/><span style="color: #408080; font-style: italic"># x can go as high as W, y as high as H</span>
<br/><span style="color: #408080; font-style: italic"># Radius of biggest possible circle contained in box is the smaller of W/2 and H/2</span>
<br/>up<span style="color: #666666">=</span>rep(c(W,H,min(W,H)<span style="color: #666666">/2</span>),N)
<br/>
<br/><span style="color: #408080; font-style: italic"># Generate initial population of guesses</span>
<br/>NumPart<span style="color: #666666">=10*3*</span>N
<br/>pop<span style="color: #666666">=</span>matrix(<span style="color: #666666">0</span>,nrow<span style="color: #666666">=</span>NumPart,ncol<span style="color: #666666">=3*</span>N)
<br/><span style="color: #008000; font-weight: bold">for</span>(i in <span style="color: #666666">1</span>:NumPart) pop[i,]<span style="color: #666666">=</span>genGuess(N,W,H)
<br/>
<br/><span style="color: #408080; font-style: italic"># L-BFGS-B test</span>
<br/>results<span style="color: #666666">=</span>c()
<br/>times<span style="color: #666666">=</span>c()
<br/>pdf(paste(<span style="color: #BA2121">&quot;L-BFGS-B&quot;</span>,root,<span style="color: #BA2121">&quot;.pdf&quot;</span>,sep<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
<br/>op<span style="color: #666666">&lt;-</span>par(mfrow<span style="color: #666666">=</span>c(arrdim,arrdim))
<br/><span style="color: #008000; font-weight: bold">for</span>(i in <span style="color: #666666">1</span>:arrnum){
<br/>	print(i)
<br/>	z<span style="color: #666666">=</span>genGuess(N,W,H); <span style="color: #408080; font-style: italic">#plotCircles(z,W,H,numbers=TRUE) # Starting guess</span>
<br/>	tim<span style="color: #666666">=</span>system.time({
<br/>		out<span style="color: #666666">=</span>optim(par<span style="color: #666666">=</span>z,fn<span style="color: #666666">=</span>obj,method<span style="color: #666666">=</span><span style="color: #BA2121">&quot;L-BFGS-B&quot;</span>,lower<span style="color: #666666">=</span>low,upper<span style="color: #666666">=</span>up,control<span style="color: #666666">=</span>list(maxit<span style="color: #666666">=300</span>)) <span style="color: #408080; font-style: italic"># Optimise</span>
<br/>		z<span style="color: #666666">=</span>as.numeric(out$par);  results<span style="color: #666666">=</span>c(results,plotCircles(z,W,H,numbers<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">FALSE</span>))<span style="color: #408080; font-style: italic"># Result</span>
<br/>	})
<br/>	times<span style="color: #666666">=</span>c(times,as.numeric(tim[<span style="color: #666666">1</span>]))
<br/>}
<br/>par(op)
<br/>op<span style="color: #666666">&lt;-</span>par(plt<span style="color: #666666">=</span>c(<span style="color: #666666">0.125</span>,<span style="color: #666666">0.95</span>,<span style="color: #666666">0.13</span>,<span style="color: #666666">0.9</span>))
<br/>plot(times,results,pch<span style="color: #666666">=16</span>)
<br/>hist(times)
<br/>hist(results)
<br/>par(op)
<br/>dev.off()
<br/>
<br/><span style="color: #408080; font-style: italic"># parallel genoud Differential optimisation test</span>
<br/>doms<span style="color: #666666">=</span>matrix(c(low,up),nrow<span style="color: #666666">=3*</span>N,ncol<span style="color: #666666">=2</span>,byrow<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">FALSE</span>) <span style="color: #408080; font-style: italic"># Format bounds</span>
<br/>results<span style="color: #666666">=</span>c()
<br/>times<span style="color: #666666">=</span>c()
<br/>cl <span style="color: #666666">&lt;-</span> makeCluster(<span style="color: #666666">12</span>, type <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;SOCK&quot;</span>) <span style="color: #408080; font-style: italic"># Initiate cluster</span>
<br/><span style="color: #408080; font-style: italic"># Unfortunately, snow clusters don't seem to respect local R variables, so we pass them as global variables to each node, like this...</span>
<br/>clusterExport(cl,list(<span style="color: #BA2121">&quot;N&quot;</span>,<span style="color: #BA2121">&quot;W&quot;</span>,<span style="color: #BA2121">&quot;H&quot;</span>))
<br/>pdf(paste(<span style="color: #BA2121">&quot;Parallelrgenoud&quot;</span>,root,<span style="color: #BA2121">&quot;.pdf&quot;</span>,sep<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
<br/>op<span style="color: #666666">&lt;-</span>par(mfrow<span style="color: #666666">=</span>c(arrdim,arrdim))
<br/><span style="color: #008000; font-weight: bold">for</span>(i in <span style="color: #666666">1</span>:arrnum){
<br/>	print(i)
<br/>	tim<span style="color: #666666">=</span>system.time({
<br/>		z<span style="color: #666666">=</span>genGuess(N,W,H); <span style="color: #408080; font-style: italic">#plotCircles(z,W,H,numbers=TRUE) # Starting guess</span>
<br/>		out<span style="color: #666666">=</span>genoud(obj,<span style="color: #666666">3*</span>N,starting.values<span style="color: #666666">=</span>z,boundary.enforcement<span style="color: #666666">=2</span>,Domains<span style="color: #666666">=</span>doms, cluster<span style="color: #666666">=</span>cl, max.generations<span style="color: #666666">=10</span>,print.level<span style="color: #666666">=0</span>,control<span style="color: #666666">=</span>list(maxit<span style="color: #666666">=300</span>))<span style="color: #408080; font-style: italic"># Optimise</span>
<br/>		z<span style="color: #666666">=</span>out$par; results<span style="color: #666666">=</span>c(results,plotCircles(z,W,H,numbers<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">FALSE</span>))<span style="color: #408080; font-style: italic"># Result</span>
<br/>	})
<br/>	times<span style="color: #666666">=</span>c(times,as.numeric(tim[<span style="color: #666666">1</span>]))
<br/>}
<br/>stopCluster(cl)
<br/>par(op)
<br/>op<span style="color: #666666">&lt;-</span>par(plt<span style="color: #666666">=</span>c(<span style="color: #666666">0.125</span>,<span style="color: #666666">0.95</span>,<span style="color: #666666">0.13</span>,<span style="color: #666666">0.9</span>))
<br/>plot(times,results,pch<span style="color: #666666">=16</span>)
<br/>hist(times)
<br/>hist(results)
<br/>par(op)
<br/>dev.off()
<br/>
<br/><span style="color: #408080; font-style: italic"># genoud Differential optimisation test</span>
<br/>doms<span style="color: #666666">=</span>matrix(c(low,up),nrow<span style="color: #666666">=3*</span>N,ncol<span style="color: #666666">=2</span>,byrow<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">FALSE</span>) <span style="color: #408080; font-style: italic"># Format bounds</span>
<br/>results<span style="color: #666666">=</span>c()
<br/>times<span style="color: #666666">=</span>c()
<br/>pdf(paste(<span style="color: #BA2121">&quot;rgenoud&quot;</span>,root,<span style="color: #BA2121">&quot;.pdf&quot;</span>,sep<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
<br/>op<span style="color: #666666">&lt;-</span>par(mfrow<span style="color: #666666">=</span>c(arrdim,arrdim))
<br/><span style="color: #008000; font-weight: bold">for</span>(i in <span style="color: #666666">1</span>:arrnum){
<br/>	print(i)
<br/>	tim<span style="color: #666666">=</span>system.time({
<br/>		z<span style="color: #666666">=</span>genGuess(N,W,H); <span style="color: #408080; font-style: italic">#plotCircles(z,W,H,numbers=TRUE) # Starting guess</span>
<br/>		out<span style="color: #666666">=</span>genoud(obj,<span style="color: #666666">3*</span>N,starting.values<span style="color: #666666">=</span>z,boundary.enforcement<span style="color: #666666">=2</span>,Domains<span style="color: #666666">=</span>doms, max.generations<span style="color: #666666">=10</span>,print.level<span style="color: #666666">=0</span>,control<span style="color: #666666">=</span>list(maxit<span style="color: #666666">=300</span>))<span style="color: #408080; font-style: italic"># Optimise</span>
<br/>		z<span style="color: #666666">=</span>out$par; results<span style="color: #666666">=</span>c(results,plotCircles(z,W,H,numbers<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">FALSE</span>))<span style="color: #408080; font-style: italic"># Result</span>
<br/>	})
<br/>	times<span style="color: #666666">=</span>c(times,as.numeric(tim[<span style="color: #666666">1</span>]))
<br/>}
<br/>par(op)
<br/>op<span style="color: #666666">&lt;-</span>par(plt<span style="color: #666666">=</span>c(<span style="color: #666666">0.125</span>,<span style="color: #666666">0.95</span>,<span style="color: #666666">0.13</span>,<span style="color: #666666">0.9</span>))
<br/>plot(times,results,pch<span style="color: #666666">=16</span>)
<br/>hist(times)
<br/>hist(results)
<br/>par(op)
<br/>dev.off()
<br/>
<br/><span style="color: #408080; font-style: italic"># DEoptim Differential optimisation test</span>
<br/>results<span style="color: #666666">=</span>c()
<br/>times<span style="color: #666666">=</span>c()
<br/>pdf(paste(<span style="color: #BA2121">&quot;DEoptim&quot;</span>,root,<span style="color: #BA2121">&quot;.pdf&quot;</span>,sep<span style="color: #666666">=</span><span style="color: #BA2121">&quot;&quot;</span>))
<br/>op<span style="color: #666666">&lt;-</span>par(mfrow<span style="color: #666666">=</span>c(arrdim,arrdim))
<br/><span style="color: #008000; font-weight: bold">for</span>(i in <span style="color: #666666">1</span>:arrnum){
<br/>	print(i)
<br/>	pop<span style="color: #666666">=</span>matrix(<span style="color: #666666">0</span>,nrow<span style="color: #666666">=</span>NumPart,ncol<span style="color: #666666">=3*</span>N)
<br/>	<span style="color: #008000; font-weight: bold">for</span>(i in <span style="color: #666666">1</span>:NumPart) pop[i,]<span style="color: #666666">=</span>genGuess(N,W,H); <span style="color: #408080; font-style: italic"># Starting guesses</span>
<br/>	tim<span style="color: #666666">=</span>system.time({
<br/>		out<span style="color: #666666">=</span>DEoptim(obj, low, up, DEoptim.control(trace<span style="color: #666666">=0</span>,itermax<span style="color: #666666">=2000</span>,NP<span style="color: #666666">=</span>NumPart,initialpop<span style="color: #666666">=</span>pop)) <span style="color: #408080; font-style: italic"># Optimise</span>
<br/>		z<span style="color: #666666">=</span>as.numeric(out$optim$bestmem);  results<span style="color: #666666">=</span>c(results,plotCircles(z,W,H,numbers<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">FALSE</span>))<span style="color: #408080; font-style: italic"># Result</span>
<br/>	})
<br/>	times<span style="color: #666666">=</span>c(times,as.numeric(tim[<span style="color: #666666">1</span>]))
<br/>}
<br/>par(op)
<br/>op<span style="color: #666666">&lt;-</span>par(plt<span style="color: #666666">=</span>c(<span style="color: #666666">0.125</span>,<span style="color: #666666">0.95</span>,<span style="color: #666666">0.13</span>,<span style="color: #666666">0.9</span>))
<br/>plot(times,results,pch<span style="color: #666666">=16</span>)
<br/>hist(times)
<br/>hist(results)
<br/>par(op)
<br/>dev.off()
<br/></pre></td></tr></table></div>
<br/>
<br/> </article></body>
</html>